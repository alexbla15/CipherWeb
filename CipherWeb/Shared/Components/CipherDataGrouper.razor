@inherits CipherComponentCard

@typeparam Cipher_TItem

@code {
    /// <summary>
    /// Available fields for grouping.
    /// </summary>
    [Parameter]
    public List<string> GroupFields { get; set; } = CommonFuncs.GetTranslatedFields(typeof(Cipher_TItem)).Select(x => x.Item2).ToList();

    /// <summary>
    /// Max amount of grouping levels.
    /// </summary>
    [Parameter]
    public int maxGroupLevels { get; set; } = 4;

    /// <summary>
    /// Current amount of group levels
    /// </summary>
    [Parameter]
    public int groupLevels { get; set; } = 0;

    /// <summary>
    /// Alert text for an empty group.
    /// </summary>
    [Parameter]
    public string EmptyGroupAlertText { get; set; } = "יש למלא את המקבץ הקודם לפני הוספת מקבץ חדש";

    /// <summary>
    /// Alert text for duplicity of groups.
    /// </summary>
    [Parameter]
    public string DuplicityGroupsAlertText { get; set; } = "אין לבחור 2 מקבצים זהים";

    /// <summary>
    /// Add group - text.
    /// </summary>
    [Parameter]
    public string AddGroupText { get; set; } = "הוספת מקבץ";
    /// <summary>
    /// Delete group - text.
    /// </summary>
    [Parameter]
    public string DeleteGroupText { get; set; } = "מחיקת מקבץ";

    /// <summary>
    /// User-chosen groups (place, property)
    /// </summary>
    [Parameter]
    public Dictionary<int, string> chosenGroups { get; set; } = new Dictionary<int, string>();

    private bool emptyGroupsAlertVisible = false;
    private bool limitedGroupsAlertVisible = false;
    private bool duplicityAlertVisible = false;
    private string limitedGroupsAlertText;

    protected override async Task OnInitializedAsync()
    {
        limitedGroupsAlertText = GetLimitedGroupsAlertText();
        chosenGroups = SetChosenGroups();
    }

    /// <summary>
    /// Alert-text for reached limit of groups
    /// </summary>
    /// <returns></returns>
    private string GetLimitedGroupsAlertText()
    {
        return "ניתן לקבוע עד " + maxGroupLevels.ToString() + " מקבצים";
    }

    private Dictionary<int, string> SetChosenGroups()
    {
        Dictionary<int, string> initialGroups = new Dictionary<int, string>();

        for (int i = 0; i < maxGroupLevels; i++)
        {
            initialGroups[i] = string.Empty;
        }
        return initialGroups;
    }

    /// <summary>
    /// Add a grouping parameter
    /// </summary>
    private void AddGroup()
    {
        if (!chosenGroups.Where(x => x.Key < groupLevels).Any(x => string.IsNullOrEmpty(x.Value)))
        {
            if (groupLevels < maxGroupLevels)
            {
                groupLevels += 1;
            }
            else
            {
                limitedGroupsAlertVisible = true;
            }
        }
        else
        {
            emptyGroupsAlertVisible = true;
        }
    }

    /// <summary>
    /// Validate if there are two identical groups.
    /// </summary>
    /// <param name="index"></param>
    private void CheckDuplicity(int index)
    {
        HashSet<string> hashed_groups = new HashSet<string>();

        foreach (string group in chosenGroups.Values)
        {
            if (!string.IsNullOrEmpty(group))
            {
                if (!hashed_groups.Add(group))
                {
                    duplicityAlertVisible = true;
                    chosenGroups[index] = string.Empty;
                }
                else
                {
                    hashed_groups.Add(group);
                }
            }
        }
    }

    /// <summary>
    /// Delete last-inserted group.
    /// </summary>
    private void DeleteGroup()
    {
        if (groupLevels > 0)
        {
            chosenGroups[groupLevels - 1] = string.Empty;
            groupLevels -= 1;
        }
    }

    /// <summary>
    /// Close the current visible alert. Reset all alerts.
    /// </summary>
    private void CloseAlert()
    {
        emptyGroupsAlertVisible = false;
        limitedGroupsAlertVisible = false;
        duplicityAlertVisible = false;
    }
}

<CipherComponentCard Title="@Title">
    <Buttons>
        <CipherAddBtn Variant="Variant.Outlined" HelpText="@AddGroupText" Click="@AddGroup" ColorStyle="ButtonStyle.Success" ColorShade="Shade.Dark"></CipherAddBtn>
        <CipherDeleteButton Variant="Variant.Outlined" HelpText="@DeleteGroupText" Click="@DeleteGroup" ColorStyle="ButtonStyle.Danger" ColorShade="Shade.Default"></CipherDeleteButton>
    </Buttons>

    <ChildContent>
        <RadzenStack Orientation="Orientation.Horizontal" Wrap="FlexWrap.Wrap" Style="padding-bottom:20px;" Gap="20px">
            @for (int i = 0; i < groupLevels; i++)
            {
                int index = i;
                <CipherFormRow Icon="@($"filter_{index+1}")" Width="240px">
                    <RadzenDropDown @bind-Value="@chosenGroups[index]" TValue="string" Change="@(args => CheckDuplicity(index))" Placeholder="@($"רמה {index+1}")"
                                    Data="@GroupFields"/>
                </CipherFormRow>
            }
        </RadzenStack>

        <RadzenAlert Visible="@emptyGroupsAlertVisible" Text="@EmptyGroupAlertText" AlertStyle="AlertStyle.Danger"
                     Style="width:98%; padding:5px; margin: 1rem 5px" Close="@CloseAlert" />
        <RadzenAlert Visible="@limitedGroupsAlertVisible" Text="@limitedGroupsAlertText" AlertStyle="AlertStyle.Danger" Style="width:98%; padding:5px; margin: 1rem 5px" Close="@CloseAlert" />
        <RadzenAlert Visible="@duplicityAlertVisible" Text="@DuplicityGroupsAlertText" AlertStyle="AlertStyle.Danger" Style="width:98%; padding:5px; margin: 1rem 5px" Close="@CloseAlert" />
    </ChildContent>
</CipherComponentCard>