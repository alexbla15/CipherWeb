@inherits CipherComponentCard

@typeparam Cipher_TItem

@code {
    /// <summary>
    /// Available fields for grouping.
    /// </summary>
    [Parameter]
    public List<CipherField> GroupFields { get; set; } = CommonFuncs.GetCipherTypeFields(typeof(Cipher_TItem));

    /// <summary>
    /// Max amount of grouping levels.
    /// </summary>
    [Parameter]
    public int maxGroupLevels { get; set; } = 4;

    /// <summary>
    /// Alert text for an empty group.
    /// </summary>
    [Parameter]
    public string EmptyGroupAlertText { get; set; } = "יש למלא את המקבץ הקודם לפני הוספת מקבץ חדש";

    /// <summary>
    /// Alert text for duplicity of groups.
    /// </summary>
    [Parameter]
    public string DuplicityGroupsAlertText { get; set; } = "אין לבחור 2 מקבצים זהים";

    /// <summary>
    /// Add group - text.
    /// </summary>
    [Parameter]
    public string AddGroupText { get; set; } = "הוספת מקבץ";
    /// <summary>
    /// Delete group - text.
    /// </summary>
    [Parameter]
    public string DeleteGroupText { get; set; } = "מחיקת מקבץ";

    /// <summary>
    /// User-chosen groups (place, property)
    /// </summary>
    [Parameter]
    public List<string> ChosenGroups { get; set; } = new();

    [Parameter]
    public EventCallback<List<string>> ChosenGroupsChanged { get; set; }

    private bool emptyGroupsAlertVisible = false;
    private bool limitedGroupsAlertVisible = false;
    private bool duplicityAlertVisible = false;
    private string? limitedGroupsAlertText;

    protected override async Task OnInitializedAsync()
    {
        limitedGroupsAlertText = GetLimitedGroupsAlertText();
        await AddGroup();
    }

    /// <summary>
    /// Alert-text for reached limit of groups
    /// </summary>
    /// <returns></returns>
    private string GetLimitedGroupsAlertText() => "ניתן לקבוע עד " + maxGroupLevels.ToString() + " מקבצים";

    /// <summary>
    /// Add a grouping parameter
    /// </summary>
    private async Task AddGroup()
    {
        if (!ChosenGroups.Where(x => ChosenGroups.IndexOf(x) < ChosenGroups.Count).Any(x => string.IsNullOrEmpty(x)))
        {
            if (ChosenGroups.Count < maxGroupLevels)
            {
                ChosenGroups.Add(string.Empty);
                StateHasChanged();
            }
            else
            {
                limitedGroupsAlertVisible = true;
            }
        }
        else
        {
            emptyGroupsAlertVisible = true;
        }

        await GroupsChanged();
    }

    /// <summary>
    /// Validate if there are two identical groups.
    /// </summary>
    /// <param name="index"></param>
    private async Task CheckDuplicity(int index)
    {
        HashSet<string> hashed_groups = new();

        foreach (string group in ChosenGroups)
        {
            if (!string.IsNullOrEmpty(group))
            {
                if (!hashed_groups.Add(group))
                {
                    await DeleteGroup();
                    duplicityAlertVisible = true;
                }
                else
                {
                    hashed_groups.Add(group);
                }
            }
        }
    }

    private async Task ChangedValue(int index, string? val)
    {
        ChosenGroups[index] = val ?? string.Empty;
        CheckDuplicity(index);

        await GroupsChanged();
    }

    /// <summary>
    /// Delete last-inserted group.
    /// </summary>
    private async Task DeleteGroup()
    {
        bool cond = ChosenGroups.Count > 0;

        if (cond) ChosenGroups.RemoveAt(ChosenGroups.Count - 1);
        StateHasChanged();
        await GroupsChanged();
    }

    /// <summary>
    /// Close the current visible alert. Reset all alerts.
    /// </summary>
    private void CloseAlert()
    {
        emptyGroupsAlertVisible = false;
        limitedGroupsAlertVisible = false;
        duplicityAlertVisible = false;
    }

    async Task GroupsChanged()
    {
        await ChosenGroupsChanged.InvokeAsync(ChosenGroups); // Trigger change event
    }
}

<CipherComponentCard Title="@Title">
    <Buttons>
        <CipherAddBtn Variant="Variant.Outlined" HelpText="@AddGroupText" Click="@AddGroup" ColorStyle="ButtonStyle.Success" ColorShade="Shade.Dark"></CipherAddBtn>
        <CipherDeleteButton Variant="Variant.Outlined" HelpText="@DeleteGroupText" Click="@DeleteGroup" ColorStyle="ButtonStyle.Danger" ColorShade="Shade.Default"></CipherDeleteButton>
    </Buttons>

    <ChildContent>
        <RadzenStack Orientation="Orientation.Horizontal" Wrap="FlexWrap.Wrap" Style="padding-bottom:20px;" Gap="20px">
            @foreach(string gr in ChosenGroups)
            {
                <CipherFormRow Icon="@($"filter_{ChosenGroups.IndexOf(gr)+1}")" Width="240px">
                    <CipherAttributeDropDown AggregationFields="@GroupFields" Change="@(args => ChangedValue(ChosenGroups.IndexOf(gr), args?.ToString()))"
                                             Placeholder="@($"רמה {ChosenGroups.IndexOf(gr)+1}")" ChosenAttribute="@gr" />
                </CipherFormRow>
            }
        </RadzenStack>

        <RadzenAlert Visible="@emptyGroupsAlertVisible" Text="@EmptyGroupAlertText" AlertStyle="AlertStyle.Danger"
                     Style="width:98%; padding:5px; margin: 1rem 5px" Close="@CloseAlert" />
        <RadzenAlert Visible="@limitedGroupsAlertVisible" Text="@limitedGroupsAlertText" AlertStyle="AlertStyle.Danger" Style="width:98%; padding:5px; margin: 1rem 5px" Close="@CloseAlert" />
        <RadzenAlert Visible="@duplicityAlertVisible" Text="@DuplicityGroupsAlertText" AlertStyle="AlertStyle.Danger" Style="width:98%; padding:5px; margin: 1rem 5px" Close="@CloseAlert" />
    </ChildContent>
</CipherComponentCard>