@using System.Text.Json;
@using System.Text.Json.Serialization;
@using System.Reflection;

@inherits CipherComponentCard

@code {
    [Parameter]
    public bool Disabled { get; set; } = false;

    [Parameter]
    public bool WithFilterButton { get; set; } = true;

    /// <summary>
    /// Help text for save-button.
    /// </summary>
    [Parameter]
    public string ActivateFilterText { get; set; } = "הפעלת סינון";

    /// <summary>
    /// Json request that will be sent to the API server.
    /// </summary>
    [Parameter]
    public string JsonRequest { get; set; } = string.Empty;

    /// <summary>
    /// All chosen conditions
    /// </summary>
    [Parameter]
    public IGroupedBooleanCondition ChosenCondition { get; set; } = Config.GroupedBooleanCondition();

    [Parameter]
    public Type? InitialType { get; set; }

    [Parameter]
    public EventCallback ValueChanged { get; set; }

    [Parameter]
    public EventCallback<IGroupedBooleanCondition> ChosenConditionChanged { get; set; }

    /// <summary>
    /// Function that occurs upon saving the conditions
    /// </summary>
    [Parameter]
    public EventCallback<object> OnFilter { get; set; }

    private RadzenDataFilter<CipherField> dataFilter = new();

    public enum FilterType
    {
        Text, Number, Date, Condition, Other
    }

    private static readonly Dictionary<AttributeRelation, FilterOperator> RelationOperatorMapping = new()
        {
        { AttributeRelation.Eq, FilterOperator.Equals },
        { AttributeRelation.Ne, FilterOperator.NotEquals },
        { AttributeRelation.Gt, FilterOperator.GreaterThan },
        { AttributeRelation.Ge, FilterOperator.GreaterThanOrEquals },
        { AttributeRelation.Lt, FilterOperator.LessThan },
        { AttributeRelation.Le, FilterOperator.LessThanOrEquals },
        { AttributeRelation.Contains, FilterOperator.Contains },
        { AttributeRelation.NotContains, FilterOperator.DoesNotContain },
        { AttributeRelation.IsEmpty, FilterOperator.IsEmpty },
        { AttributeRelation.IsNotEmpty, FilterOperator.IsNotEmpty },
        { AttributeRelation.IsNull, FilterOperator.IsNull },
        { AttributeRelation.IsNotNull, FilterOperator.IsNotNull },
        { AttributeRelation.StartsWith, FilterOperator.StartsWith },
        { AttributeRelation.EndsWith, FilterOperator.EndsWith },
            };

    private static readonly Dictionary<string, AttributeRelation> RelationTranslationMapping = new()
            {
        { Translate(nameof(AttributeRelation.Eq)), AttributeRelation.Eq },
        { Translate(nameof(AttributeRelation.Ne)), AttributeRelation.Ne },
        { Translate(nameof(AttributeRelation.Gt)), AttributeRelation.Gt },
        { Translate(nameof(AttributeRelation.Ge)), AttributeRelation.Ge },
        { Translate(nameof(AttributeRelation.Lt)), AttributeRelation.Lt },
        { Translate(nameof(AttributeRelation.Le)), AttributeRelation.Le },
        { Translate(nameof(AttributeRelation.Contains)), AttributeRelation.Contains },
        { Translate(nameof(AttributeRelation.NotContains)), AttributeRelation.NotContains },
        { Translate(nameof(AttributeRelation.IsEmpty)), AttributeRelation.IsEmpty },
        { Translate(nameof(AttributeRelation.IsNotEmpty)), AttributeRelation.IsNotEmpty },
        { Translate(nameof(AttributeRelation.IsNull)), AttributeRelation.IsNull },
        { Translate(nameof(AttributeRelation.IsNotNull)), AttributeRelation.IsNotNull },
        { Translate(nameof(AttributeRelation.StartsWith)), AttributeRelation.StartsWith },
        { Translate(nameof(AttributeRelation.EndsWith)), AttributeRelation.EndsWith },
            };

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (string.IsNullOrEmpty(Title)) Title = "תנאים נבחרים";

        if (firstRender)
        {
            await Clear();

            dataFilter.LogicalFilterOperator = (ChosenCondition.Operator == Operator.All) ? 
            LogicalFilterOperator.And : LogicalFilterOperator.Or;

            foreach (var cond in ChosenCondition.Conditions)
            {
                if (cond is IBooleanCondition)
                {
                    await dataFilter.AddFilter(AddBooleanConditionFilter(cond as IBooleanCondition));
                }
                else if (cond is IGroupedBooleanCondition)
                {
                    await dataFilter.AddFilter(AddGroupedBooleanConditionFilter(cond as IGroupedBooleanCondition));
                }
            }

            StateHasChanged();
        }
    }

    public CompositeFilterDescriptor AddBooleanConditionFilter(IBooleanCondition? cond)
        => (cond is null) ? new() : new CompositeFilterDescriptor
                {
                    Property = cond.Attribute,
                    FilterValue = cond.Value,
                    FilterOperator = RelationOperatorMapping.TryGetValue(cond.AttributeRelation ?? AttributeRelation.Eq, out var relation)
                    ? relation : FilterOperator.In
                };

    public CompositeFilterDescriptor AddGroupedBooleanConditionFilter(IGroupedBooleanCondition? cond)
    {
        if (cond is null) return new();

        CompositeFilterDescriptor new_filter = new()
        {
            LogicalFilterOperator = (cond.Operator == Operator.All) ? LogicalFilterOperator.And : LogicalFilterOperator.Or
        };

        if (cond.Conditions != null)
        {
            List<CompositeFilterDescriptor> subFilters = cond.Conditions
            .Select(subCond => subCond switch
            {
                IBooleanCondition booleanCond => AddBooleanConditionFilter(booleanCond),
                IGroupedBooleanCondition groupedCond => AddGroupedBooleanConditionFilter(groupedCond),
                _ => new CompositeFilterDescriptor()
            })
            .Where(x => x != new CompositeFilterDescriptor()).ToList();

            new_filter.Filters = subFilters;
        }

        return new_filter;
    }

    /// <summary>
    /// Filter is a Boolean condition (no sub filters)
    /// </summary>
    public IBooleanCondition SetBooleanCondition(CompositeFilterDescriptor filter)
    {
        IBooleanCondition cond = Config.BooleanCondition();
        cond.Attribute = filter.Property;

        if (filter.FilterValue != null)
        {
            var ParsedFilter = ParseFilter(filter);

            cond.Attribute = ParsedFilter.Name;
            cond.Value = ParsedFilter.Value;
            cond.Operator = ParsedFilter.Operator;

            string? filterRelation = ParsedFilter.Relation;

            if (filterRelation != null)
            {
                if (RelationTranslationMapping.TryGetValue(filterRelation, out var relation))
                {
                    cond.AttributeRelation = relation;
                }
            }
        }

        return cond;
    }

    /// <summary>
    /// Filter is a Grouped Boolean condition (no sub filters)
    /// </summary>
    public IGroupedBooleanCondition SetGroupedBooleanCondition(CompositeFilterDescriptor filter)
    {
        IGroupedBooleanCondition cond = Config.GroupedBooleanCondition();

        cond.Operator = filter.LogicalFilterOperator == LogicalFilterOperator.And ? Operator.All : Operator.Any;

        List<ICondition> conditions = new();

        foreach (var sub_filter in filter.Filters)
        {
            conditions.Add(sub_filter.Filters is null ? SetBooleanCondition(sub_filter) : SetGroupedBooleanCondition(sub_filter));
        }

        cond.Conditions = conditions;
        return cond;
    }

    public void Save(IQueryable<CipherField>? fields = null)
    {
        ChosenCondition.Operator = dataFilter.LogicalFilterOperator == LogicalFilterOperator.And ? Operator.All : Operator.Any;

        List<ICondition> conditions = new();
        foreach (var filter in dataFilter.Filters)
        {
            //if (fields!=null)
            //{
            //    filter.Property ??= fields.ToList()[dataFilter.Filters.ToList().IndexOf(filter)].Path;
            //}

            // decide if it is a GroupedCondition or BooleanCondition

            conditions.Add((filter.Filters is null) ? SetBooleanCondition(filter) : SetGroupedBooleanCondition(filter));
        }

        ChosenCondition.Conditions = conditions;
        //OnFilter.InvokeAsync();
    }

    async Task ParamsChanged(IQueryable<CipherField>? fields = null)
    {
        Save(fields);
        await ChosenConditionChanged.InvokeAsync(ChosenCondition); // Trigger change event
        await ValueChanged.InvokeAsync();
        SetJson();
    }

    public void SetJson() => JsonRequest = ChosenCondition.ToJson();

    /// <summary>
    /// Clears all fields in the filter, and resets set-condition and json
    /// </summary>
    public async Task Clear()
    {
        ChosenCondition = Config.GroupedBooleanCondition();
        SetJson();
        await dataFilter.ClearFilters();
    }

    private static string Translate(string key) => Translator.GetTranslation(key);

    ///  <summary>
    /// Method to control the including all data of a filter within its value
    /// </summary>
    /// <param name="prop">a filter description which will contain all the data</param>
    /// <param name="update_name">should the name be updated?</param>
    /// <param name="update_value">should the value be updated?</param>
    /// <param name="update_relation">should the relation be updated?</param>
    /// <param name="changeParams">should activate changed-params function after this method?</param>
    /// <param name="update_islist">should update isList?</param>
    /// <param name="update_operator">should update operator?</param>
    /// <param name="name">value to be set as name upon update</param>
    /// <param name="value">value to be set as value upon update</param>
    /// <param name="relation">value to be set as relation upon update</param>
    /// <param name="isList">value to be set as isList upon update</param>
    /// <param name="_operator">value to be set as operator upon update</param>
    private async void ChangeProperty(CompositeFilterDescriptor prop,
    bool update_name = false, bool update_value = false, bool update_relation = false,
    bool changeParams = true, bool update_islist = false, bool update_operator = false, bool update_type = false,
    string? name = null, string? value = null, string? relation = null, bool isList = false, Operator? _operator = null,
    FilterType filterType = FilterType.Other)
    {
        var ParsedFilter = ParseFilter(prop);

        string? newName = update_name ? name : ParsedFilter.Name;
        string? newRel = update_relation ? relation : ParsedFilter.Relation;
        string? newVal = update_value ? value?.Replace("#","") : ParsedFilter.Value;
        bool newIsList = update_islist ? isList : ParsedFilter.IsList;
        Operator? newOperator = update_operator ? _operator : ParsedFilter.Operator;
        FilterType newType = update_type ? filterType : ParsedFilter.Type;

        // make value initially null / 0 / false / now
        if (string.IsNullOrEmpty(newVal)) newVal = GetDefaultValue(newType);
        // make value null if checking for IsNull or something that doesn't require a value
        if (IsCheckingNullOrEmpty(newRel)) newVal = null;

        prop.FilterValue = $"{newName}###{newVal ?? " "}###{newRel ?? " "}###{newIsList}###{newOperator?.ToString() ?? " "}###{newType}";

        if (changeParams) await ParamsChanged();
    }

    ///  <summary>
    /// Pasing filter according to a scheme of "{item}###{item2}..."
    /// </summary>
    private (string? Name, string? Value, string? Relation, bool IsList, Operator Operator, FilterType Type)
    ParseFilter(CompositeFilterDescriptor filter)
    {
        var parts = filter.FilterValue?.ToString()?.Split("###");
        return (
        parts?.ElementAtOrDefault(0)?.Trim(),
        parts?.ElementAtOrDefault(1)?.Trim(),
        parts?.ElementAtOrDefault(2)?.Trim(),
        Convert.ToBoolean(parts?.ElementAtOrDefault(3)),
        parts?.ElementAtOrDefault(4) == "All" ? Operator.All : Operator.Any,
        Enum.TryParse(parts?.ElementAtOrDefault(5), out FilterType type) ? type : FilterType.Other
    );
    }

    private FilterType GetFilterType(CipherField field)
    {
        Type type = field.FieldType;
        if (typeof(bool?).IsAssignableFrom(field.FieldType)) return FilterType.Condition;
        if (typeof(DateTime?).IsAssignableFrom(field.FieldType)) return FilterType.Date;
        if (typeof(decimal?).IsAssignableFrom(field.FieldType)) return FilterType.Number;
        if (typeof(string).IsAssignableFrom(field.FieldType)) return FilterType.Text;
        if (field.IsList()) return GetFilterType(new CipherField() { FieldType = field.ItemType() });
        else return FilterType.Other;
    }

    private string? GetDefaultValue(FilterType type)
    {
        if (type == FilterType.Text) return null;
        if (type == FilterType.Date) return DateTime.Now.ToString();
        if (type == FilterType.Condition) return false.ToString();
        if (type == FilterType.Number) return "0";
        return null;
    }

    private bool IsCheckingNullOrEmpty(string? rel)
    {
        var operators = new List<string> {
            nameof(FilterOperator.IsNull),
            nameof(FilterOperator.IsNotNull),
            nameof(FilterOperator.IsEmpty),
            nameof(FilterOperator.IsNotEmpty),
            };
        return operators.Select(x => Translate(x)).Contains(rel);
    }

    private bool IsCheckingNullOrEmpty(CompositeFilterDescriptor prop) =>
        IsCheckingNullOrEmpty(ParseFilter(prop).Relation);

    private string FixedWidth() =>
        $"width:{Constants.StandardWidth}; min-width:{Constants.StandardWidth}; max-width:{Constants.StandardWidth}";

    private RenderFragment? FilterBtn()
        => (!Disabled && WithFilterButton) ?
    @<CipherButton Icon="@Icons.SearchAndFilter.filter_alt" Variant="Variant.Outlined"
                  Click="@(async args => {
                      await ParamsChanged(); 
                      await OnFilter.InvokeAsync();
                  })" HelpText="@ActivateFilterText" /> : null;

    private RenderFragment? JsonBox()
        => Disabled ? null : @<CipherJsonCheck JsonValue="@JsonRequest" Visible="@Constants.CheckJsons" />;

    private RenderFragment AttributeDropDown(CompositeFilterDescriptor context)
    {
        return
    @<RadzenStack Orientation="Orientation.Horizontal" JustifyContent="JustifyContent.Center"
                      AlignItems="AlignItems.Center">
        <div style="width:100%">
            <CipherPathChooser Path="@ParseFilter(context).Name" InitialType="@InitialType"
                               PathChanged="@(value => {
                CipherField field = value.Item2;
                ChangeProperty(context, update_name:true, update_value: true, update_islist: true, update_type: true, update_operator:true,
                    update_relation: true, name: value.Item1, isList: value.Item3,  filterType: GetFilterType(field));})" />
        </div>
        @RelationDropDown(context)
        @if (!IsCheckingNullOrEmpty(context))
        {
            @ValueFiller(context)
        }
    </RadzenStack>
        ;
    }

    private RenderFragment? RelationDropDown(CompositeFilterDescriptor context)
    {
        FilterType filterType = ParseFilter(context).Type;
        List<string> filters = new();

        if (filterType == FilterType.Number) filters = CipherField.NumberFilters;
        if (filterType == FilterType.Date) filters = CipherField.DateFilters;
        if (filterType == FilterType.Condition) filters = CipherField.BoolFilters;
        if (filterType == FilterType.Text) filters = CipherField.TextFilters;

        filters = filters.Select(x => Translate(x)).ToList();

        // SET DEFAULT VALUE
        string defaultValue = ParseFilter(context).Relation ?? Translate(nameof(FilterOperator.Equals));

        if (!filters.Any()) return null;

        return
    @<RadzenDropDown TValue=string Data="@filters" Value="@defaultValue" Style="@($"min-width:{Constants.StandardWidth}; max-width:{Constants.StandardWidth}")"
                    Change="@(args=> ChangeProperty(context, update_relation:true, relation:args.ToString()))" />
        ;
    }

    private RenderFragment NumberFiller(CompositeFilterDescriptor filter)
    {
        string val = ParseFilter(filter).Value ?? string.Empty;
        if (string.IsNullOrEmpty(val)) val = "0";
        return
        @<RadzenNumeric TValue="decimal" Value="@(decimal.Parse(val))" Style="@($"width:100%; min-width:{Constants.StandardWidth}")"
                   ValueChanged="@(value => ChangeProperty(filter, update_value:true, value: value.ToString()))" />
        ;
    }

    private RenderFragment DateFiller(CompositeFilterDescriptor filter)
    {
        string val = ParseFilter(filter).Value ?? string.Empty;
        DateTime? date = DateTime.TryParse(val, out _) ? DateTime.Parse(val) : null;
        return
        @<RadzenDatePicker TValue="DateTime" Value="@date" Style="@($"width:100%; min-width:{Constants.StandardWidth}")"
        ValueChanged="@(value => ChangeProperty(filter, update_value:true, value: value.ToString()))" ShowTime="true" ShowTimeOkButton="true" />
    ;
    }

    private RenderFragment ConditionFiller(CompositeFilterDescriptor filter)
    {
        string val = ParseFilter(filter).Value ?? string.Empty;
        if (string.IsNullOrEmpty(val)) val = false.ToString();

        return
        @<RadzenToggleButton Value="@(bool.Parse(val))" Style="display:flex; justify-content:end"
                        ValueChanged="@(value => ChangeProperty(filter, update_value:true, value: value.ToString()))"
                        Text="@(val == false.ToString() ? "לא" : "כן" )"
                        ButtonStyle="ButtonStyle.Danger" Disabled="@Disabled"
                        ToggleButtonStyle="ButtonStyle.Success" />
        ;
    }

    private RenderFragment TextFiller(CompositeFilterDescriptor filter)
    {
        return
    @<RadzenTextBox Disabled="@Disabled" Style="@($"width:100%; min-width:{Constants.StandardWidth}")"
                   Value="@ParseFilter(filter).Value"
        ValueChanged="@(value => ChangeProperty(filter, update_value:true,value:value))" />
    ;
    }

    private RenderFragment? ValueFiller(CompositeFilterDescriptor filter)
    {
        FilterType filterType = ParseFilter(filter).Type;

        if (filterType == FilterType.Number) return NumberFiller(filter);
        if (filterType == FilterType.Date) return DateFiller(filter);
        if (filterType == FilterType.Condition) return ConditionFiller(filter);
        if (filterType == FilterType.Text) return TextFiller(filter);

        return null;
    }

    private RenderFragment? OperatorDropDown(CompositeFilterDescriptor filter)
    {
        var ParsedFilter = ParseFilter(filter);

        if (!ParsedFilter.IsList || ParsedFilter.Type == FilterType.Other) return null;

        return
    @<RadzenStack Orientation="Orientation.Horizontal" JustifyContent="JustifyContent.Right"
                      AlignItems="AlignItems.Center">
        <RadzenIcon Icon="@Icons.Arrows.Circled.arrow_circle_left" IconColor="@Colors.PrimaryDark" />
        <RadzenDropDown Style="@FixedWidth()" TValue="Operator" Disabled="@Disabled"
                        Value="@(ParseFilter(filter).Operator)"
                        ValueChanged="@(value => ChangeProperty(filter, update_operator:true, _operator:value))"
                        Data="@(new List<Operator>() {Operator.Any, Operator.All})" Placeholder="אופרטור">
            <ValueTemplate Context="operator_value_context">
                @if (operator_value_context == Operator.All)
                {
                    @(
                        "כל האיברים"
                            )
                }
                else
                {
                    @(
                        "לפחות אחד"
                            )
                }
            </ValueTemplate>
            <Template Context="operator_context">
                @if (operator_context == Operator.All)
                {
                    @(
                        "כל האיברים"
                            )
                }
                else
                {
                    @(
                        "לפחות אחד"
                            )
                }
            </Template>
        </RadzenDropDown>
    </RadzenStack>;
    }
}

<CipherComponentCard Title="@Title" Visible="@Visible">
    <Buttons>
        @FilterBtn()
    </Buttons>
    <ChildContent>
        <RadzenStack Orientation="Orientation.Vertical" Gap="10px">
            <RadzenDataFilter TItem="CipherField" @ref=dataFilter Data="@(new List<CipherField>())"
                              ViewChanged="@(async args => {await ParamsChanged(args);})" Auto=true
                              RemoveFilterText="@Translate("RemoveFilter")"
                              AddFilterText="@Translate("AddFilter")"
                              AddFilterGroupText="@Translate("AddFilterGroup")"
                              ClearFilterText="@Translate("ClearFilter")"
                              ApplyFilterText="@Translate("ApplyFilter")"
                              FilterText="@Translate("Filter")"
                              AndOperatorText="@Translate("AndOperator")"
                              OrOperatorText="@Translate("OrOperator")">
                <Properties>
                    <RadzenDataFilterProperty TItem="CipherField" Property="" Title="">
                        <FilterTemplate>
                            @if (context != null)
                            {
                                <RadzenStack Orientation="Orientation.Horizontal" JustifyContent="JustifyContent.Right"
                                             AlignItems="AlignItems.Center" Style="width:100%">
                                    @AttributeDropDown(context)
                                    @OperatorDropDown(context)
                                </RadzenStack>
                            }
                        </FilterTemplate>
                    </RadzenDataFilterProperty>
                </Properties>
            </RadzenDataFilter>
            @JsonBox()
        </RadzenStack>
    </ChildContent>
</CipherComponentCard>