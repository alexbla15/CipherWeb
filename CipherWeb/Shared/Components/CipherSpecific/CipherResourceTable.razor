@inherits CipherTableCard

@typeparam Cipher_TItem

<CipherTableCard Title="@Title" MaxWidth="@MaxWidth" Width="@Width" GetDataSource="@GetDataSource" WithCard="@WithCard" WithButtons="@WithButtons"
                 Sharable="@Sharable" Variant="@Variant" IsReport="@IsReport"
                 FileTitle="@FileTitle" ExcelExport=@ExcelExport PDFExport=@PDFExport ExpandPath="@ExpandPath" Height="@Height" MarginBottom="@MarginBottom">
    <HeaderContent>
        @if (WithHeaderContent)
        {
            <RadzenStack AlignItems="AlignItems.Start" JustifyContent="JustifyContent.Stretch">
                <CipherLocation WithIcon=false Label="בחירת מערכת" Change="SearchFunc" @ref=ChosenSystem/>
            </RadzenStack>
        }
    </HeaderContent>
    <ComponentContent>
        @if (ChosenSystem.ChosenSystem != null && !ChosenObjects.Any())
        {
            <CipherLoadingCard/>
        }
        else
        {
            <CipherDataTable @ref=DataGrid DataSource="@DisplayedObject.ListObjects(ChosenObjects)"
                         GridFilterMode="@GridFilterMode" AllowFilter="@AllowFilter" AllowGroup="@AllowGroup" />
        }
    </ComponentContent>
</CipherTableCard>

@code {
    private CipherLocation ChosenSystem = new();

    /// <summary>
    /// Filter mode of data grid. Must be a FilterMode-enum.
    /// </summary>
    [Parameter]
    public FilterMode GridFilterMode { get; set; } = FilterMode.SimpleWithMenu;

    /// <summary>
    /// Is the datagrid filterable.
    /// </summary>
    [Parameter]
    public bool AllowFilter { get; set; } = false;

    /// <summary>
    /// Is the datagrid groupable.
    /// </summary>
    [Parameter]
    public bool AllowGroup { get; set; } = false;

    /// <summary>
    /// Is a CipherAutoComplete header is needed.
    /// </summary>
    [Parameter]
    public bool WithHeaderContent { get; set; } = true;

    /// <summary>
    /// File name - title prefix (e.g. events_[id].csv).
    /// </summary>
    [Parameter]
    public string PrefixFileTitle { get; set; } = "exported_data";

    /// <summary>
    /// All events for scheduler
    /// </summary>
    [Parameter]
    public IEnumerable<Cipher_TItem> ChosenObjects { get; set; } = new List<Cipher_TItem>();

    /// <summary>
    /// Error response of fetching data
    /// </summary>
    [Parameter]
    public ErrorResponse Error { get; set; } = ErrorResponse.Success;

    [Parameter]
    public CipherDataTable DataGrid { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        if (ChosenSystem.ChosenSystem != null) await SearchFunc();
        SetFileName();
    }

    /// <summary>
    /// Function taking place upon clicking Enter.
    /// </summary>
    private async Task SearchFunc()
    {
        if (ChosenSystem.ChosenSystem is null) ChosenObjects = new List<Cipher_TItem>();
        else (ChosenObjects, Error) = await GetSearchedValues();
        var res = DisplayedObject.ListObjects(ChosenObjects);
        SetFileName();
    }

    private async Task<Tuple<List<Cipher_TItem>, ErrorResponse>> GetSearchedValues()
    {
        var badFetch = Tuple.Create(new List<Cipher_TItem>(), ErrorResponse.BadRequest);

        if (ChosenSystem.ChosenSystem != null)
        {
            if (typeof(Cipher_TItem) == typeof(IEvent))
            {
                var res = await Config.Event(false).All();
                return (Tuple<List<Cipher_TItem>, ErrorResponse>?)(object?)res;
            }
            else if (typeof(Cipher_TItem) == typeof(IProcess))
            {
                var res = await Config.Process(false).All();
                return (Tuple<List<Cipher_TItem>, ErrorResponse>?)(object?)res;
            }
            else if (typeof(Cipher_TItem) == typeof(IPackage))
            {
                var res = await Config.Package(false).All();
                return (Tuple<List<Cipher_TItem>, ErrorResponse>?)(object?)res;
            }
            else if (typeof(Cipher_TItem) == typeof(IVessel))
            {
                var res = await Config.Vessel(false).All();
                return (Tuple<List<Cipher_TItem>, ErrorResponse>?)(object?)res;
            }
            else if (typeof(Cipher_TItem) == typeof(IUnit))
            {
                var res = await Config.Unit(false).All();
                return (Tuple<List<Cipher_TItem>, ErrorResponse>?)(object?)res;
            }
        }
        else
        {
            if (typeof(Cipher_TItem) == typeof(IEvent)) return await GetEvents();
            else if (typeof(Cipher_TItem) == typeof(IProcess)) return await GetProcesses();
            else if (typeof(Cipher_TItem) == typeof(IPackage)) return await GetPackages();
            else if (typeof(Cipher_TItem) == typeof(IVessel)) return await GetVessels();
        }
        return Tuple.Create(new List<Cipher_TItem>(), ErrorResponse.Success);
    }

    private async Task<Tuple<List<Cipher_TItem>, ErrorResponse>> GetEvents()
    {
        var badFetch = Tuple.Create(new List<Cipher_TItem>(), ErrorResponse.BadRequest);
        Tuple<List<IEvent>, ErrorResponse>? result = await ChosenSystem.ChosenSystem.Events();
        if (result is null) return badFetch;
        else return (Tuple<List<Cipher_TItem>, ErrorResponse>?)(object?)result;
    }

    private async Task<Tuple<List<Cipher_TItem>, ErrorResponse>> GetProcesses()
    {
        var badFetch = Tuple.Create(new List<Cipher_TItem>(), ErrorResponse.BadRequest);
        Tuple<List<IProcess>, ErrorResponse>? result = await ChosenSystem.ChosenSystem.Processes();
        if (result is null) return badFetch;
        else return (Tuple<List<Cipher_TItem>, ErrorResponse>?)(object?)result;
    }

    private async Task<Tuple<List<Cipher_TItem>, ErrorResponse>> GetPackages()
    {
        var badFetch = Tuple.Create(new List<Cipher_TItem>(), ErrorResponse.BadRequest);
        Tuple<List<IPackage>, ErrorResponse>? result = await ChosenSystem.ChosenSystem.Packages();
        if (result is null) return badFetch;
        else return (Tuple<List<Cipher_TItem>, ErrorResponse>?)(object?)result;
    }

    private async Task<Tuple<List<Cipher_TItem>, ErrorResponse>> GetVessels()
    {
        var badFetch = Tuple.Create(new List<Cipher_TItem>(), ErrorResponse.BadRequest);
        Tuple<List<IVessel>, ErrorResponse>? result = await ChosenSystem.ChosenSystem.Vessels();
        if (result is null) return badFetch;
        else return (Tuple<List<Cipher_TItem>, ErrorResponse>?)(object?)result;
    }

    public void SetFileName() => FileTitle = ChosenSystem.ChosenSystem is null ? PrefixFileTitle : $"{PrefixFileTitle}_{ChosenSystem.ChosenSystem?.Id}";
}