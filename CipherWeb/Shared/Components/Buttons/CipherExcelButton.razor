@inherits CipherButton

@using System.Text
@using System.Collections

@using OfficeOpenXml
@using System.IO

@inject NavigationManager Navigation
@inject ExcelService excelService
@inject IJSRuntime JSRuntime
@inject IJSRuntime JS

<CipherButton HelpText="@HelpText" Icon="@Icon" ColorStyle="ButtonStyle.Success" ColorShade="Shade.Dark"
              Click="@ExportToCSV" Variant="Variant.Outlined" />

@code
{
    /// <summary>
    /// Name of output file.
    /// </summary>
    [Parameter]
    public string? FileName { get; set; }

    /// <summary>
    /// Data that will be exported to Excel.
    /// </summary>
    [Parameter]
    public IEnumerable<object>? Data { get; set; }

    protected override void OnInitialized()
    {
        HelpText ??= "ייצוא ל-EXCEL";
        Icon ??= Icons.Cipher.Excel;
    }

    private async Task ExportToCSV()
    {
        if (Data == null || !Data.Any()) return; // Exit if there's no data

        var csvData = GenerateCSV(Data);
        var fileName = $"{FileName}.csv"; // Change the file extension to .csv
        var mimeType = "text/csv"; // Specify UTF-8 charset

        var csvBytes = Encoding.UTF8.GetBytes(csvData);

        // Convert CSV data to Base64
        var base64String = Convert.ToBase64String(Encoding.UTF8.GetBytes(csvData));

        // Create data URL for download
        var url = $"data:{mimeType};base64,{base64String}";

        // Trigger download
        await JSRuntime.InvokeVoidAsync("BlazorDownloadFile", url, fileName);
    }

    private string GenerateCSV(IEnumerable<object> data)
    {
        using (var stream = new MemoryStream())
        {
            using (var writer = new StreamWriter(stream, Encoding.UTF8))
            {
                if (data == null || !data.Any())
                    return string.Empty;

                var firstItem = data.First();

                // Get all property names from the first item
                Type type = firstItem.GetType();
                var properties = type.GetProperties();

                // Write headers with translation if available
                var headers = properties.Select(p =>
                {
                    var translateMethod = type.GetMethod("Translate");
                    if (translateMethod != null)
                    {
                        // Assuming the Translate method takes the property name as an argument
                        return translateMethod.Invoke(firstItem, new object[] { p.Name })?.ToString();
                    }
                    return p.Name;
                }).ToArray();
                writer.WriteLine(string.Join(",", headers));

                // Write data rows
                foreach (var item in data)
                {
                    var values = properties.Select(p =>
                    {
                        var value = p.GetValue(item, null);
                        if (value != null)
                        {
                            var valueType = value.GetType();

                            // Check if the value is a collection (like List, IEnumerable, etc.)
                            if (typeof(System.Collections.IEnumerable).IsAssignableFrom(valueType) && valueType != typeof(string))
                            {
                                var idList = new List<string>();
                                foreach (var subItem in (System.Collections.IEnumerable)value)
                                {
                                    // try to save a list of all contained names, otherwise all contained ids
                                    var idProperty = subItem?.GetType().GetProperty("Name");
                                    if (idProperty != null)
                                    {
                                        var idValue = idProperty.GetValue(subItem)?.ToString();
                                        if (idValue != null) idList.Add(idValue);
                                    }
                                    // all contained ids within item
                                    else
                                    {
                                        idProperty = subItem?.GetType().GetProperty("Id");
                                        if (idProperty != null)
                                        {
                                            var idValue = idProperty.GetValue(subItem)?.ToString();
                                            if (idValue != null) idList.Add(idValue);
                                        }
                                    }
                                }
                                return string.Join(";", idList); // Join IDs
                            }
                            else
                            {
                                // Check if the value is an object with a Name property
                                var idProperty = valueType.GetProperty("Name");
                                if (idProperty != null)
                                {
                                    return idProperty.GetValue(value)?.ToString();
                                }
                                // if it doesn't, save it's id
                                else
                                {
                                    idProperty = valueType.GetProperty("Id");
                                    if (idProperty != null) return idProperty.GetValue(value)?.ToString();
                                }
                                return value.ToString()?.Replace(",", ";");
                            }
                        }

                        return string.Empty;
                    }).ToArray();

                    writer.WriteLine(string.Join(",", values));
                }
            }

            return Encoding.UTF8.GetString(stream.ToArray());
        }
    }
}